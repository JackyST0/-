# 面试问题

1. 什么是拆箱，什么是装箱？
```
简单一点说，装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。(xxx代表对应的基本数据类型)。
```

2. AOP的相关注解？
```
AOP意为面向切面编程，是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。为的是使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
@Aspect	
切面声明，标注在类、接口（包括注解类型）或枚举上。

@Pointcut	
切入点声明，即切入到哪些目标类的目标方法。既可以用 execution 切点表达式, 也可以是 annotation 指定拦截拥有指定注解的方法.（value 属性指定切入点表达式，默认为 ""，用于被通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式）

@Before	
前置通知, 在目标方法(切入点)执行之前执行。（value 属性绑定通知的切入点表达式，可以关联切入点声明，也可以直接设置切入点表达式。注意：如果在此回调方法中抛出异常，则目标方法不会再执行，会继续执行后置通知 -> 异常通知。）    

@After	
后置通知, 在目标方法(切入点)执行之后执行

@AfterReturning	
返回通知, 在目标方法(切入点)返回结果之后执行.（pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 ""）

@AfterThrowing	
异常通知, 在方法抛出异常之后执行, 意味着跳过返回通知（pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 ""。注意：如果目标方法自己 try-catch 了异常，而没有继续往外抛，则不会进入此回调函数）

@Around	
环绕通知：目标方法执行前后分别执行一些代码，类似拦截器，可以控制目标方法是否继续执行。通常用于统计方法耗时，参数校验等等操作。
```

3. 执行SQL语句时是先进行排序还是先分组？
```
先分组（group by）后排序（order by）
```

4. String常用的方法？
```
length() 字符串的长度
charAt() 截取一个字符
toCharArray() String转换成char数组
equals()和equalsIgnoreCase() 比较两个字符串
replace() 替换
valueOf() 转换为字符串
toLowerCase() 转换为小写
toUpperCase()转换为大写
```

5. Collection和Collections的区别？
```
java.util.Collection 是一个 集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。
java.util.Collections 是一个包装类。它包含有各种有关集合操作的 静态多态方法。此类 不能实例化，就像一 个工具类，服务于Java的Collection框架。

Collections.sort():对集合进行排序;
Collections.reverse():反转集合中元素的顺序;
Collections.copy(m,n):将集合n中的元素全部复制到m中,并且覆盖相应索引的元素;
Collections.min():采用Collection内含自然比较法求最小值;
Collections.max():采用Collection内含自然比较法求最大值;
```

6. 为什么重写 equals 时为什么一定要重写 hashCode？
```
因为重写了equals方法能证明两个对象相等，但没有重写hashCode方法意味着用的是object类的方法，就有可能两个都对象的hashCode不相同，就矛盾了，所以重写equals方法就一定要重写hashCode，然后在比较的时候先调用hashCode方法判断hashCode值是否相同，不同就证明两个对象不相等，相等就再调用equals方法进而判断两个对象相不相同。
```

7. array和arrayList的区别？
```
（1）ArrayList是Array的复杂版本：arrayList相当于array的一个增强版，因为arraylist的许多方法，如Index、IndexOf、Contains、Sort等都是在内部数组的基础上直接调用Array的对应方法。
（2）存储的数据类型：ArrayList可以存储异构对象，而Array只能存储相同数据类型的数据。
（3）长度的可变：定义一个 Array 时，必须指定数组的数据类型及数组长度，其长度定义后就不可变了。而ArrayList 是动态数组，长度动态可变，会自动扩容。
```

8. 你可以接受加班吗？
```
第一个方面：你可以这样去跟面试官说：如果是因为我个人工作效率低的原因，从而导致我需要加班，我可以接受。同时我也会去反思自己的工作方式，从而去提高自己的工作效率，减少加班的情况。
第二个方面：你可以这样去跟面试官说：如果不是因为我个人的原因，并且我个人手头上的工作已经超量完成，我可能接受不了无偿加班。我相信贵公司也是需要有能力的人，这样公司才能更好的进步，所以我觉得不必要的加班还是应该避免的。
```

9. 请解释一下什么是高并发，以及在Java中如何处理高并发问题?
```
高并发是指系统在同一时间内处理大量请求的能力。在Java中，我们可以使用线程池、锁、队列等方式来处理高并发问题。其中，线程池可以控制线程的数量，避免线程过多导致系统崩溃;锁可以保证同一时间只有一个线程访问共享资源，避免数据不一致;队列可以缓存请求，避免系统瞬间被大量请求压垮。
```

10. 请解释一下什么是压测，以及在Java中如何进行压测?
```
压测是指模拟大量用户同时访问系统，测试系统的性能和稳定性。在Java中，我们可以使用JMeter等工具进行压测。JMeter可以模拟大量用户同时访问系统，并记录系统的响应时间、吞吐量等指标，帮助我们评估系统的性能和稳定性。
```

11. sql（查询表中前十行）？
```
select * from table_name limit 0,10
```

12. 如何优化mysql的limit问题？
```
利用覆盖索引来加速分页查询
```

13. 如何创建多线程？
```
1、继承Thread类，重写run()方法，使用start()启动；
2、实现Runnable接口，重写run()方法，使用start()启动；
3、实现Callable接口，重写call()方法，使用start()启动。
```

14. 线程池的核心参数？
```
corePoolSize：核心线程数，是指线程池中长期存活的线程数。
maximumPoolSize：最大线程数，线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。
keepAliveTime：空闲线程存活时间，当线程池中没有任务时，会销毁一些线程，销毁的线程数=maximumPoolSize（最大线程数）-corePoolSize（核心线程数）。
TimeUnit：时间单位，空闲线程存活时间的描述单位。
BlockingQueue：线程池任务队列，线程池存放任务的队列，用来存储线程池的所有待执行任务。
ThreadFactory：创建线程的工厂，线程池创建线程时调用的工厂方法，通过此方法可以设置线程的优先级、线程命名规则以及线程类型（用户线程还是守护线程）等。	
RejectedExecutionHandler：拒绝策略，当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。
```

15. MySQL 可重复读隔离级别，如何解决幻读问题？
```
针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题；
针对当前读（select ... for update 等语句），是通过 next-key lock（行锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。
```

16. hashmap和hashtable的区别？
```
1、哈希计算方法不同：Hashmap会对key进行两次hash运算，然后对table数组长度取模；Hashtable则进行了一次然后对table数组的长度直接进行取模。
2、键值是否可以为空值：HashMap可以使用null作为key；Hashtable则不允许null作为key。
3、实现方式不同：HashMap 继承的是 AbstractMap 类；Hashtable 继承的是 Dictionary类。
4、初始化容量不同：HashMap 的初始容量为：16；Hashtable 初始容量为：11。
5、扩容机制不同：已用容量>总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍；已用容量>总容量 * 负载因子时，Hashtable 扩容规则为当前容量翻倍 +1。
6、支持的遍历种类不同：HashMap只支持Iterator遍历；HashTable支持Iterator和Enumeration两种方式遍历。
```

17. Hashmap什么时候扩容，几倍？
```
当HashMap中的元素个数超过数组大小 \*loadFactor（扩容因子）时，就会进行数组扩容，loadFactor（扩容因子）的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16\*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。
```

18. ArrayList什么时候扩容，几倍？
```
当数组的大小大于初始容量的时候(比如初始为10，当添加第11个元素的时候)，就会进行扩容，新的容量为旧的容量的1.5倍。
```

19. 讲讲Java内存模型？
```
java内存模型是Java Memory Model（JMM）的意思，简单地说，JMM定义了一套在多线程读写共享数据（成员变量、数组）时，对数据的可见性、有序性和原子性的规则和保障。
```

20. Synchronized实现原理？
```
synchronized的底层实现是完全依赖JVM虚拟机的，是基于JMM也就是Java内存模型来实现的，使用这个模型能很好的保证synchronized的原子性、可见性、有序性。一般synchronized可以作用于实例方法、静态方法和代码块上，然后加synchronized锁是解决高并发最常用也是最简单的一种方法，目的就是可以保证在同一时刻，被修饰的代码块或方法只会有一个线程执行。
```

21. token怎么生成的？
```
Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
```

22. 什么是面向对象编程？
```
面向对象编程是一种编程范式或分类，它将一组具有函数或方法的数据属性组织成一个单元，称为对象。面向对象编程有四个基本概念：封装、抽象、继承和多态性。封装意味着通过将数据包含在对象中来封闭数据。抽象是指使用简化的类而不是复杂的实现代码来访问对象。继承是指父类有的属性功能，子类同样也具有，就说子类继承了父类。多态性是指创建具有共享行为的对象。
```

23. 抽象类和接口的区别？
```
1、定义关键字不同：接口使用关键字interface来定义，抽象类使用关键字abstract来定义。
2、继承或实现的关键字不同：接口使用implements关键字定义其具体实现，抽象类使用extends关键字实现继承。
3、子类扩展的数量不同：接口的实现类可以有多个，而抽象类的子类只能继承一个抽象类。
4、方法实现方式不同：接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。
5、单继承、多实现：一个类只能继承一个抽象类（单继承），但可以实现多个接口。
```

24. 创建线程池的方法？
```
JAVA中创建线程池主要有两类方法，一类是通过Executors工厂类提供的方法，该类提供了4种不同的线程池可供使用。另一类是通过ThreadPoolExecutor类进行自定义创建。
一、通过Executors类提供的方法。
1、newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。
2、newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。
3、newScheduledThreadPool：创建一个周期性的线程池，支持定时及周期性执行任务。
4、newSingleThreadExecutor：创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
二、通过ThreadPoolExecutor类自定义，共7个参数如下：
（1）corePoolSize：核心线程数，线程池中始终存活的线程数。
（2）maximumPoolSize: 最大线程数，线程池中允许的最大线程数。
（3）keepAliveTime: 存活时间，线程没有任务执行时最多保持多久时间会终止。
（4）unit: 单位，参数keepAliveTime的时间单位，7种可选。
（5）workQueue: 一个阻塞队列，用来存储等待执行的任务，均为线程安全，7种可选。
（6）threadFactory: 线程工厂，主要用来创建线程，默及正常优先级、非守护线程。
（7）handler：拒绝策略，拒绝处理任务时的策略，4种可选，默认为AbortPolicy。
```

25. MySQL 和 Redis 事务的区别？
```
redis 事务不支持原子性和持久性，并且 mysql 事务与 redis 事务的实现原理不同：
mysql 是基于 undo/redo 日志实现事务
undo 记录修改前状态，rollback 基于 undo 日志实现
redo 记录修改后状态，commit 基于 redo 日志实现
redis 是基于 commands 队列实现事务
没有开启事务，command将会被立即执行并返回执行结果，并且直接写入磁盘
开启事务，command不会被立即执行，而是排入队列，并返回排队状态（具体依赖于客户端（例如：spring-data-redis）自身实现）
```

26. 什么是动态sql？
```
动态sql就是根据不同的条件生成不同的sql语句。所谓的动态sql，本质还是sql语句，只是我们可以在sql层面，去执行一个逻辑代码。动态sql就是在拼接sql语句，我们只要保证sql正确性，按照sql的格式，去排列组合就可以了。
```

27. Sychronized和ReentrantLock的区别？
```
1、sychronized是⼀个关键字，ReentrantLock是⼀个类
2、sychronized会⾃动的加锁与释放锁，ReentrantLock需要程序员⼿动加锁与释放锁
3、sychronized的底层是JVM层⾯的锁，ReentrantLock是API层⾯的锁
4、sychronized是⾮公平锁，ReentrantLock可以选择公平锁或⾮公平锁
5、sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态
6、sychronized底层有⼀个锁升级的过程
```

28. Hashmap 和 Map 的区别？
```
1、Map 是一种抽象数据类型，代表了一组键值对的映射，它是一个接口。而Hashmap 是Map的一个具体实现类。因此，可以说Hashmap 是Map的子类，通过继承和实现Map接口，Hashmap 提供了对键值对的增删改查操作。
2、Hashmap 使用哈希表来实现键值对的存储，以此实现高效的插入、查找和删除操作。
3、Hashmap 的键是唯一的，即同一个键只能存在一个对应的值。如果插入了两个相同的键，后一个键的值会覆盖前一个键的值。
4、Hashmap 允许键和值为null。
5、Hashmap 不是线程安全的。如果有多个线程同时访问和修改同一个Hashmap 实例，可能会导致数据不一致的问题。
```

29. Spring Cloud和Dubbo有哪些区别？
```
Spring Cloud是⼀个微服务框架，提供了微服务领域中的很多功能组件，Dubbo⼀开始是⼀个RPC调⽤框架，核⼼是解决服务调⽤间的问题，Spring Cloud是⼀个⼤⽽全的框架，Dubbo则更侧重于服务调⽤，所以Dubbo所提供的功能没有Spring Cloud全⾯，但是Dubbo的服务调⽤性能⽐Spring Cloud⾼，不过Spring Cloud和Dubbo并不是对⽴的，是可以结合起来⼀起使⽤的。
```

30. MyBatis和Mybatis Plus的区别？
```
MyBatis是基于XML或注解方式进行数据库操作的持久化框架，它提供了简单的CRUD操作及动态SQL生成等功能。而MyBatis-Plus是在MyBatis框架上的封装，通过对于增强简化后的API更加方便地进行开发，并且在性能、效率和易用性上都有一定的优化。
MyBatis:
1）所有SQL语句全部自己写
2）手动解析实体关系映射转换为MyBatis内部对象注入容器
3）不支持Lambda形式调用
Mybatis Plus:
1）强大的条件构造器,满足各类使用需求
2）内置的Mapper,通用的Service,少量配置即可实现单表大部分CRUD操作
3）支持Lambda形式调用
4）提供了基本的CRUD功能,连SQL语句都不需要编写
5）自动解析实体关系映射转换为MyBatis内部对象注入容器
```

31. sql调优？
```
1、可以用explain关键字来分析sql的执行情况，是否走索引。
2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。
4、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
5、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。
6、in 和 not in 也要慎用，否则会导致全表扫描。
7、少用select *，因为select * 增加很多不必要的消耗（CPU、IO、内存、网络带宽）。
```

32. volatile和synchronized的区别？
```
volatile 是 Java 中的关键字，用于声明变量。它的作用是确保多个线程之间对该变量的访问具有可见性和顺序性。
1、volatile是变量修饰符，而synchronized则作用于一段代码或方法。
2、volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值, 显然synchronized要比volatile消耗更多资源。
3、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
4、volatile保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存中和公共内存中的数据做同步。
5、volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
```

33. hashmap和concurrenthashmap的区别？
```
1、HashMap的底层数据结构主要是：数组+链表，确切的说是由链表为元素的数组。
ConcurrentHashMap的底层数据结构是：分段（Segments）的数组+链表。
2、HashMap是线程不安全的，当出现多线程操作时，会出现安全隐患；而ConcurrentHashMap是线程安全的。
3、HashMap不支持并发操作，没有同步方法；ConcurrentHashMap支持并发操作。	
```

34. TCP和UDP的区别？
```
1、TCP是面向连接的，UDP是面向无连接的。
2、TCP是可靠的，UDP是不可靠的。
3、TCP是面向字节流的，UDP是面向报文的。
4、TCP只有一对一的传输方式，而UDP不仅可以一对一，还可以一对多，多对多。
5、UDP的头部开销小，TCP的头部开销大。
6、TCP会产生粘包问题，UDP会产生丢包问题。
```

35. 七层协议和四层协议？
```
1：OSI七层协议:物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
2：tcp/ip四层模型  ：链路层、网络层、传输层、应用层。
```

36. sleep和wait的区别？
```
1、sleep是线程类（Thread）的方法；wait是Object类的方法。
2、sleep是使线程休眠，不会释放对象锁；wait是使线程等待，释放锁。
3、调用sleep进入阻塞状态；调用wait进入等待状态，调用notify进入就绪状态。
```

37. 线程的状态有哪些？调用start()是什么状态？
```
1、在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。
2、就绪状态调用了start()。
```

38. 雪花算法和uuid区别？
```
雪花算法：
优点：
1、高并发分布式环境下生成不重复 id，每秒可生成百万个不重复 id。
2、基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增。
3、不依赖第三方库或者中间件。
4、算法简单，在内存中进行，效率高。
缺点：
1、不一定是全局递增的(存储机器码导致)。
2、依赖服务器时间，服务器时钟回拨时可能会生成重复 id。
uuid：
优点：
1、性能非常高，本地生成，没有网络消耗。
缺点：
不易于存储，UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。
信息不安全，基于MAC地址生成UUID的算法可能会造成MAC地址泄露。
```

39. Java中的异常体系是怎样的？
```
● Java中的所有异常都来⾃顶级⽗类Throwable。
● Throwable下有两个⼦类Exception和Error。
● Error表示⾮常严重的错误，Exception表示异常，表示程序出现Exception时，是可以靠程序⾃⼰来解决的。
● Exception的⼦类通常⼜可以分为RuntimeException和⾮RuntimeException两类。
● RunTimeException表示运⾏期异常，表示这个异常是在代码运⾏过程中抛出的，这些异常是⾮检查异常，程序中可以选择捕获处理，也可以不处理。这些异常⼀般是由程序逻辑错误引起的，程序应该从逻辑⻆度尽可能避免这类异常的发⽣，⽐如NullPointerException、IndexOutOfBoundsException等。
● ⾮RuntimeException表示⾮运⾏期异常，也就是我们常说的检查异常，是必须进⾏处理的异常，如果不处理，程序就不能检查异常通过。如IOException、SQLException等以及⽤户⾃定义的Exception异常。
```

40. 常见的http状态码？
```
1、200 OK：请求成功，服务器成功处理了请求并返回相应的内容。
2、201 Created：请求成功，并且服务器创建了新的资源。
3、204 No Content：请求成功，服务器成功处理了请求，但没有返回任何内容。
4、400 Bad Request：客户端请求存在语法错误或无效，服务器无法理解请求的格式。
5、401 Unauthorized：请求需要进行身份验证，但客户端未提供有效的身份验证凭据。
6、403 Forbidden：服务器理解请求，但拒绝提供服务。客户端没有访问权限或身份验证失败。
7、404 Not Found：请求的资源在服务器上未找到，通常是由于路径或文件名不存在或输入有误。
8、500 Internal Server Error：服务器在处理请求时遇到了内部错误，可能由于配置问题、程序错误等引起。
9、503 Service Unavailable：服务器当前无法处理请求，通常是由于过载或临时维护导致。
10、301 Moved Permanently：请求的资源已经被永久移动到一个新的位置，客户端需要使用新的URL进行访问。
11、302 Found：请求的资源已经被临时移动到一个新的位置，客户端需要进行重定向操作以获取资源。
```

41. spring和springboot？
```
Spring：
Spring是一个轻量级的Java开发框架，用于构建企业级应用程序。它通过提供一系列的模块和功能来简化Java开发过程，并提供了对各种技术的集成支持，例如依赖注入（Dependency Injection）、面向切面编程（Aspect-Oriented Programming）、事务管理、Web开发等。Spring框架具有松耦合、可测试性和可扩展性等优点，广泛应用于企业级Java应用程序的开发中。
Spring Boot：
Spring Boot是基于Spring框架的快速应用开发框架，旨在简化Spring应用程序的创建和配置。它提供了一种约定优于配置的方式，通过自动配置和默认值设置，可以快速构建独立的、可执行的、生产级的Spring应用程序。Spring Boot还集成了许多常用的第三方库和组件，如日志、数据库访问、消息队列等，进一步简化了开发过程。Spring Boot提倡"习惯优于配置"的理念，可以快速启动和部署应用，适合构建微服务和云原生应用。
```

42. static 和 final 的区别有哪些？
```
被final修饰的变量为常量一旦赋值不能修改,被final修饰的方法为最终方法不能被重写，被final修饰的类是最终类，不能被继承。被static修饰的变量和方法，为该整个类及其类的对象所共享，一个类或对象修改了被定义的变量或方法，其他的也会跟着变。
```

43. 什么是哈希冲突？
```
哈希冲突（Hash Collision）是指不同的输入数据在经过哈希函数计算之后得到了相同的哈希值，也就是说，两个或多个不同的键值被映射到了哈希表中的同一个位置。哈希冲突是哈希表中常见的问题，因为哈希函数的输出空间可能比输入空间小很多，因此一定会有多个输入映射到同一个输出的情况。
哈希表解决冲突的主要方法有以下几种：
链地址法（Separate Chaining）：将所有哈希值相同的元素存储在一个链表中；
开放地址法（Open Addressing）：当哈希值冲突时，继续探查数组中的其他元素，找到下一个可用的空槽；
再哈希法（Double Hashing）：当哈希值冲突时，使用第二个哈希函数来计算下一个可用的槽位，直到找到一个空槽。
```

44. java的public，private， protected， default作用范围？
```
public：所有类，所有包可见
private：本类可见
protected：本包和所有子类可见（本包中的子类可访问，不同包中的子类可以访问，不是子类不能访问）
default：本包可见（本包中的子类和非子类均可访问，不同包中的类及子类不能访问）
```

45. Spring中的事务是如何实现的？
```
1、Spring事务底层是基于数据库事务和AOP机制的；
2、⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean；
3、当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解；
4、如果加了，那么则利⽤事务管理器创建⼀个数据库连接；
5、并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮常重要的⼀步；
6、然后执⾏当前⽅法，⽅法中会执⾏sql；
7、执⾏完当前⽅法后，如果没有出现异常就直接提交事务；
8、如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务；
9、spring事务实现完成。
```

46. Spring事务传播机制？
```
多个事务⽅法相互调⽤时，事务如何在这些⽅法间传播，⽅法A是⼀个事务的⽅法，⽅法A执⾏过程中调⽤了⽅法B，那么⽅法B有⽆事务以及⽅法B对事务的要求不同都会对⽅法A的事务具体执⾏造成影响，同时⽅法A的事务对⽅法B的事务执⾏也有影响，这种影响具体是什么就由两个⽅法所定义的事务传播类型所决定。
1、REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则⾃⼰新建⼀个事务，如果当前存在事务，则加⼊这个事务；
2、SUPPORTS：当前存在事务，则加⼊当前事务，如果当前没有事务，就以⾮事务⽅法执⾏；
3、MANDATORY：当前存在事务，则加⼊当前事务，如果当前事务不存在，则抛出异常；
4、REQUIRES_NEW：创建⼀个新事务，如果存在当前事务，则挂起该事务；
5、NOT_SUPPORTED：以⾮事务⽅式执⾏,如果当前存在事务，则挂起当前事务；
6、NEVER：不使⽤事务，如果当前事务存在，则抛出异常；
7、NESTED：如果当前事务存在，则在嵌套事务中执⾏，否则REQUIRED的操作⼀样（开启⼀个事
务）
```

47. Spring容器启动流程是怎样的？
```
1、在创建Spring容器，也就是启动Spring时：
2、⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中；
3、然后筛选出⾮懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建；
4、利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化后这⼀步骤中；
5、单例Bean创建完了之后，Spring会发布⼀个容器启动事件；
6、Spring启动结束。
```

48. #{}和${}的区别是什么？
```
1、#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符；
2、Mybatis在处理#{}时，会将sql中的#{}替换为?号，调⽤ PreparedStatement 来赋值；
3、Mybatis在处理${}时，会将sql中的${}替换成变量的值，调⽤ Statement 来赋值；
4、使⽤#{}可以有效的防⽌ SQL 注⼊， 提⾼系统安全性。
```

49. @autowired和@resource注解的区别？
```
1、来源不同，Autowired注解是 Spring 定义的注解，而Resource 注解是 Java 定义的注解；
2、注入规则不同，Autowired注解是spring的注解,此注解只根据type进行注入,不会去匹配name.但是如果只根据type无法辨别注入对象时,就需要配合使用@Qualifier注解或者@Primary注解使用。
Resource注解有两个重要的属性，分别是name和type，如果name属性有值，则使用byName的自动注入策略，将值作为需要注入bean的名字，如果type有值，则使用byType自动注入策略，将值作为需要注入bean的类型。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略；
3、依赖查找的顺序不同，Autowired注解先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找。Resource注解先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找；
4、支持的参数不同，Autowired注解只支持设置 1 个参数，而Resource注解支持设置 7 个参数；
5、依赖注入的用法支持不同，Autowired注解支持属性注入、构造方法注入和 Setter 注入，而Resource注解只支持属性注入和 Setter 注入。
```

50. 左连接 ，右连接，内连接和全外连接的4者区别？
```
left join （左连接）：返回包括左表中的所有记录和右表中与连接字段相等的记录。
right join （右连接）：返回包括右表中的所有记录和左表中与连接字段相等的记录。
inner join （等值连接或者叫内连接）：只返回两个表中与连接字段相等的行。
full join （全外连接）：返回左右表中所有的记录和左右表中与连接字段相等的记录。
```

51. 主键索引和普通索引有什么区别?
```
主键索引也被称为聚簇索引,叶子节点存放的是整行数据; 而非主键索引被称为二级索引,叶子节点存放的是主键的值.
如果根据主键查询, 只需要搜索ID这颗B+树，而如果通过非主键索引查询, 需要先搜索k索引树, 找到对应的主键, 然后再到ID索引树搜索一次, 这个过程叫做回表.
总结, 非主键索引的查询需要多扫描一颗索引树, 效率相对更低.
```

52. java中IO流分为几种？
```
1.字节输入流(InputStream)
2.字节输出流(OutputStream)
3.字符输入流(Reader)
4.字符输出流(Writer)
```

53. 什么是反射？
```
反射就是指在 Java 程序运行时：
给定的一个类（Class）对象，通过反射获取这个类（Class）对象的所有成员结构；
给定的一个具体的对象，能够动态地调用它的方法及对任意属性值进行获取和赋值。
优势：
增加程序的灵活性，避免将固有的逻辑程序写死到代码里；
代码简洁，可读性强，可提高代码的复用率。
劣势：
相较直接调用，在量大的情景下反射性能下降；
存在一些内部暴露和安全隐患。
```